{
	"apex.debug": {
		"prefix": ["apex.","apex.debug.log"],
		 "scope": "javascript",
		"body": ["apex.debug.log(logPrefix,$message)"],
		"description": "Nitro apex.debug.log"
	 },
	"jsdoc-def": {
		"prefix": ["/**","fdef"],
		 "scope": "javascript",
		"body": ["/***",
					   " * $description",
					   " * @param   {$paramType} $paramName   - $paramDescription",
					   " * @returns {$returnType} $returnName - $returnDescription",
					   " */"
				    ],
		"description": "JS Doc Function Definition"
	 },
	"jsdoc-typedef": {
		"prefix": ["/**","typedef"],
		 "scope": "javascript",
		"body": ["/***",
					   " * $Description",
					   " * @typedef  {Object} $objectName",
					   " * @property {$type} $propname - $returnDescription",
					   " */"
				    ],
		"description": "JS Doc Function Definition"
	 },
	"apex.setValue": {
		"prefix": ["apex.item","apex.item(","apex.set"],
		 "scope": "javascript",
		"body": ["apex.item(cGlobals.$itemName).setValue($itemValue)"],
		"description": "Nitro apex.debug.log"
	 },
	"apex.getValue": {
		"prefix": ["apex.item","apex.item(", "apex.get"],
		 "scope": "javascript",
		"body": ["apex.item(cGlobals.$itemName).getValue()"],
		"description": "Nitro apex.debug.log"
	 },
	"tmsnest.existsById": {
		"prefix": ["existsById","tapiExistsById"],
		 "scope": "typescript",
		"body": ["",
      "public async existsBy$id($id: $type): Promise<WrapResult<boolean>> {",
      "  this.logger.log(`Exists ID: ${id}`)",
      "  const sql=`",
      "    select count(1) as cnt",
      "      from ${this.schema}.${this.tablename}",
      "      where $column = :$id",
      "  `",
      "  const binds: BindParameters = [$id]",
      "  return this.tapiService.existsPk(sql,binds)",
      "}",
      ""
		],
		"description": "Tapi Function to find if Unique Key exists"
	 },
	"tmsnest.findBy": {
		"prefix": ["findById","tapiFindBy"],
		 "scope": "typescript",
		"body": ["",
      "public async findBy$id($id: $type): Promise<WrapResult<$returnType>> {",
      "  this.logger.log(`Finding $id: ${id}`)",
      "  const sql=`",
      "    select *",
      "      from ${this.schema}.${this.tablename}",
      "      where $column = :$id",
      "  `",
      "  const binds: BindParameters = [$id]",
      "  const notFoundMsg =`$ID ${id} not found!`",
      "  const results = await this.tapiService.findById(sql,binds,notFoundMsg)",
      "  if (results.isSuccess) {",
      "    const typedResults = <$returnType[]>results.r.rows",
      "    return WrapResult.make(true,null, typedResults[0])",
      "  } else WrapResult.make(false,results.errorMsg)",
      "}",
      ""
		],
		"description": "Tapi Function to find Unique Key"
	 },
	"tmsnest.insert": {
		"prefix": ["insert","tapiInsert","tapinsert"],
		 "scope": "typescript",
		"body": ["",
      "public async insert(dto: $type, connection: Connection): Promise<WrapResult<number>> {",
      "  this.logger.log('Creating Record...')",
      "  const sql=`",
      "  insert into ${this.schema}.${this.tablename} (", 
      "     insert_on,",
      "     insert_by,",
      "     ,",
      "  ) values (",
      "     :insert_on,",
      "     :insert_by,",
      "     ,",
      "  ) returning $column into :id",
      "  `",
      "  const sysdate = await this.tapiService.getSysdate()",
      "  if(!sysdate.isSuccess){",
      "     return WrapResult.make(false, sysdate.errorMsg)",
      "  }",
      "  const binds: BindParameters = {",
      "    insert_on: sysdate.r.sysdate,",
      "    insert_by: dto.$insert_by",
      "    id: {",
      "      type: NUMBER,",
      "      dir: BIND_OUT,",
      "    },",
      "  }",
      "  return await this.tapiService.insert(sql,binds,connection)",
      "}",
      ""
		],
		"description": "Tapi Function to Insert a new Record"
	 },
	"tmsnest.update": {
		"prefix": ["update","tapiUpdate","tapiupdate"],
		 "scope": "typescript",
		"body": ["",
      "public async update(dto: $type, connection: Connection): Promise<WrapResult<number>> {",
      "  this.logger.log('updating a Record...')",
      "  const sql=`",
      "    update ${this.schema}.${this.tablename} ", 
      "       set last_updated_on = :last_updated_on",
      "          ,last_updated_by = :last_updated_by",
      "     where $pk = :id",
      "  `",
      "  const sysdate = await this.tapiService.getSysdate()",
      "  if(!sysdate.isSuccess){",
      "     return WrapResult.make(false, sysdate.errorMsg)",
      "  }",
      "  const binds: BindParameters = {",
      "    id: dto.$id,",
      "    last_updated_on: sysdate.r.sysdate,",
      "    last_updated_by: dto.$last_updated_by",
      "  }",
      "  const res = await this.tapiService.dml(sql, binds, connection)",
      "  return res.isSuccess",
      "    ? WrapResult.make(true, null, res.r.result.rowsAffected)",
      "    : WrapResult.make(false,res.errorMsg)",
      "}",
      ""
		],
		"description": "Tapi Function to Update the record"
	 },
	"tmsnest.delete": {
		"prefix": ["delet","tapiDelete","tapidelete"],
		 "scope": "typescript",
		"body": ["",
      "public async delete(id: $type, connection: Connection): Promise<WrapResult<number>> {",
      "  this.logger.log(`Deleting ID ${id}`)",
      "  const sql=`",
      "    delete from ${this.schema}.${this.tablename} ", 
      "       where $column = :id",
      "  `",
      "  const binds: BindParameters = [id]",
      "  const res = await this.tapiService.dml(sql, binds, connection)",
      "  this.logger.debug(`ID ${id} Deleted Affected: ${res.r.result.rowsAffected}`)",
      "  return res.isSuccess",
      "    ? WrapResult.make(true, null, res.r.result.rowsAffected)",
      "    : WrapResult.make(false,res.errorMsg)",
      "}",
      ""
		],
		"description": "Tapi Function to delete a record"
	 },
	"For Loop": {
		"prefix": ["for","for i in"],
		 "scope": "plsql",
		"body": ["for i in cursor_name",
					 "loop",
					 "\t",
					 "end loop;"
				  ],
		"description": "A for loop."
	 },
	 "If-vReturn": {
		 "scope": "plsql",
		 "prefix": ["if","if v_return.is_err","is_err"],
		 "body": [ "if v_return.is_err",
					  " then return v_return;",
					  "end if;"
					],
		 "description": "Exit the function is VReturn is error"
	  },
	 "Create Sequence": {
		 "scope": "plsql",
		 "prefix": ["create","sequenc"],
		 "body": ["prompt ****",
					  "prompt ****",
					  "prompt ****",
			        "   create sequence $schema.$TM_FILENAME_BASE",
					  "      minvalue 1",
					  "      increment by 1",
					  "      start with 1",
					  "      cache 20",
					  "      noorder",
					  "      nocycle;",
					  "prompt ****",
					  "prompt ****",
					  "prompt ****",
					],
		 "description": "create regular sequence"
	  },
	  "Package Spec": {
		  "scope": "plsql",
		  "prefix": ["create"],
		  "body": ["set define off;",
						"create or replace package $schema.$TM_FILENAME_BASE",
						"as ",
						"  /**",
						"   * @project     ",
						"   * @description ",
						"   *",
						"   * @author:  yvan.florian ",
						"   * @created: $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
						"   * changelog:",
						"   * $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR - yvan.florian Package Creation",
						"   */ ",
						"\t",
						 "end $TM_FILENAME_BASE;",
						 "/",
						 "show errors;"
					 ],
		  "description": "create package specification"
		},
	  "Package Body": {
		  "scope": "plsql",
		  "prefix": ["create"],
		  "body": ["set define off;",
						"create or replace package body $schema.$TM_FILENAME_BASE",
						"as ",
						"  gc_scope_prefix constant varchar2(31) := lower($$$plsql_unit) || '.';",
						"",
						"end $TM_FILENAME_BASE;",
						"/",
						"show errors;",
						"alter package $schema.$TM_FILENAME_BASE compile;"
					 ],
		  "description": "create package Body"
		},
		"(OFS)Package Body": {
			"scope": "plsql",
			"prefix": ["create"],
			"body": ["set define off;",
						 "create or replace package body $schema.$TM_FILENAME_BASE",
						 "as ",
						 "  c_package_name    constant varchar2(30) := '$TM_FILENAME_BASE.';",
						 "  v_exception_id    number;",
						 "",
						 "end $TM_FILENAME_BASE;",
						 "/",
						 "show errors;",
						 "alter package $schema.$TM_FILENAME_BASE compile;"
					  ],
			"description": "(OFS)create package Body"
		 },
		"Function Package Source": {
			"scope": "plsql",
			"prefix": ["function","func"],
			"body": [  "/** ",
				        " * Function $DESCRIPTION",
				        " *",
				        " * @param $pi_ ",
				        " *",
				        " * @author  Florian Yvan",
				        " * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
				        " * @return  ",
						  " */",
						  "function $function_name(",
						  "  $pi_   in %type",
						  " ) return $returnType;"
					  ],
			"description": "(ALL)Function with its Description in the Package Specification"
		 },
		 "Procedure Package Source": {
			 "scope": "plsql",
			 "prefix": ["procedure","proc"],
			 "body": [  "",
							"/** ",
							" * Procedure $description",
							" *",
							" * @param $pi_ ",
							" *",
							" * @author  Florian Yvan",
							" * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
							" */",
							"procedure $procedure_name (",
							"  $pi_   in %type",
							" );"
						],
			 "description": "(ALL)Procedure with its Description in the Package Specification"
		  },
		 "Function Package Body": {
			 "scope": "plsql",
			 "prefix": ["function","func"],
			 "body": [  "",
							"/*! ",
							" * Function $DESCRIPTION ",
							" *",
							" * @param $pi_param ",
							" *",
							" * @author  Florian Yvan",
							" * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
							" * @return  ",
							" */",
							"function $function_name(",
							"  $pi_param   in $rowtype%type",
							" ) return $return_type",
							"is ",
							"   v_scope    logger_logs.scope%type := gc_scope_prefix || '$function_name';",
							"   v_params   logger.tab_param;",
							"   v_return   $return_type;",
							"begin   ",
							"   logger.append_param(v_params,'$pi_param',$pi_param);",
							"   logger.log('START',v_scope,null,v_params);",
							"\t\t",
							"\t\t",
							"   v_return :=  ",
							"\t\t",
							"   logger.log('STOP', v_scope, null, v_params);",
							"   return(v_return); ",
							"exception",
							"   when others",
							"   then logger.log_error(const_pkg.c_when_others_message, v_scope);",
							"        raise;",
							"end $function_name;",
							"",
						],
			 "description": "(TMS)Function in a Package Body with Logger Statements"
		  },
		  "Function Package Body (No Param)": {
			  "scope": "plsql",
			  "prefix": ["function","func"],
			  "body": [  "",
							 "/*! ",
							 " * Function $DESCRIPTION ",
							 " *",
							 " *",
							 " * @author  Florian Yvan",
							 " * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
							 " * @return  ",
							 " */",
							 "function $function_name return $return_type",
							 "is ",
							 "   v_scope    logger_logs.scope%type := gc_scope_prefix || '$function_name';",
							 "   v_params   logger.tab_param;",
							 "   v_return   $return_type;",
							 "begin   ",
							 "   logger.log('START',v_scope,null,v_params);",
							 "\t\t",
							 "\t\t",
							 "   v_return :=  ",
							 "\t\t",
							 "   logger.log('STOP', v_scope, null, v_params);",
							 "   return(v_return); ",
							 "exception",
							 "   when others",
							 "   then logger.log_error(const_pkg.c_when_others_message, v_scope);",
							 "        raise;",
							 "end $function_name;",
							 "",
						 ],
			  "description": "(TMS)Function in a Package Body with Logger Statements and no Param"
			},
		  "Insert TAPI-Function Package Body": {
			  "scope": "plsql",
			  "prefix": ["function","func"],
			  "body": [  "",
							 "/*! ",
							 " * Function to create a record in the Table",
							 " *",
							 " * @param pi_row ",
							 " *",
							 " * @author  Florian Yvan",
							 " * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
							 " * @return  ",
							 " */",
							 "function f_insert(",
							 "  pi_row  in $tablename%rowtype",
							 " ) return call_result",
							 "is ",
							 "   v_scope      logger_logs.scope%type := gc_scope_prefix || 'f_insert';",
							 "   v_params     logger.tab_param;",
							 "   v_return     call_result;",
							 "   v_return_id  number;",
							 "begin   ",
							 "   logger.append_param(v_params,'pi_row.$pk',pi_row.$pk);   ",
							 "   logger.log('START',v_scope,null,v_params); ",
							 "\t\t",
							 "   insert into $tablename(",
							 "     insert_on",
							 "    ,insert_by",
							 "    ,",
							 "   ) values(",
							 "     sysdate",
							 "    ,coalesce(v('APP_USER'),user)",
							 "    ,",
							 "   ) returning $pk into v_return_id;",
							 "\t\t",
							 "   v_return := handle_pkg.ok_message( ",
							 "         pretius_apex_util_pkg.f_lang('PRETIUS_TAPI_SUCCESS_INSERT')",
							 "       , v_return_id",
							 "       , v_scope",
							 "   );",
							 "\t\t",
							 "   logger.log('STOP', v_scope, null, v_params); ",
							 "   return(v_return); ",
							 "exception",
							 "   when others",
							 "   then logger.log_error(const_pkg.c_when_others_message, v_scope);",
							 "        raise;",
							 "end f_insert;",
							 "",
						 ],
			  "description": "(TMS)Function in a Package Body with Logger Statements"
			},
			"Update TAPI-Function Package Body": {
				"scope": "plsql",
				"prefix": ["function","func"],
				"body": [  "",
							  "/*! ",
							  " * Function to Update a record",
							  " *",
							  " * @param pi_row ",
							  " *",
							  " * @author  Florian Yvan",
							  " * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
							  " * @return  ",
							  " */",
							  "function f_update(",
							  "  pi_row  in $tablename%rowtype",
							  " ) return call_result",
							  "is ",
							  "   v_scope     logger_logs.scope%type := gc_scope_prefix || 'f_update';",
							  "   v_params    logger.tab_param;",
							  "   v_return    call_result;",
							  "begin   ",
							  "   logger.append_param(v_params,'pi_row.$pk',pi_row.$pk);   ",
							  "   logger.log('START',v_scope,null,v_params); ",
							  "\t\t",
							  "   update $tablename",
							  "      set last_updated_on  = sysdate",
							  "         ,last_updated_by  = coalesce(v('APP_USER'),user)",
							  "         ,",
							  "     where $pk = pi_row.$pk;",
							  "\t\t",
							  "   v_return := handle_pkg.ok_message( ",
							  "         pretius_apex_util_pkg.f_lang('PRETIUS_TAPI_SUCCESS_UPDATE')",
							  "       , pi_row.$pk",
							  "       , v_scope",
							  "   );",
							  "\t\t",
							  "   logger.log('STOP', v_scope, null, v_params); ",
							  "   return(v_return); ",
							  "exception",
							  "   when others",
							  "   then logger.log_error(const_pkg.c_when_others_message, v_scope);",
							  "        raise;",
							  "end f_update;",
							  "",
						  ],
				"description": "(TMS) TAPI Update Function in a Package Body with Logger Statements"
			 },
			 "Delete TAPI-Function Package Body": {
				 "scope": "plsql",
				 "prefix": ["function","func"],
				 "body": [  "",
								"/*! ",
								" * Function to Delete a record",
								" *",
								" * @param pi_row ",
								" *",
								" * @author  Florian Yvan",
								" * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
								" * @return  ",
								" */",
								"function f_delete(",
								"  pi_row  in $tablename%rowtype",
								" ) return call_result",
								"is ",
								"   v_scope     logger_logs.scope%type := gc_scope_prefix || 'f_delete';",
								"   v_params    logger.tab_param;",
								"   v_return    call_result;",
								"begin   ",
								"   logger.append_param(v_params,'pi_row.$pk',pi_row.$pk);",
								"   logger.log('START',v_scope,null,v_params); ",
								"\t\t",
								"   delete from $tablename",
								"    where $pk = pi_row.$pk; ",
								"\t\t",
								"   v_return := handle_pkg.ok_message( ",
								"         pretius_apex_util_pkg.f_lang('PRETIUS_TAPI_SUCCESS_DELETE')",
								"       , null",
								"       , v_scope",
								"   );",
								"\t\t",
								"   logger.log('STOP', v_scope, null, v_params); ",
								"   return(v_return); ",
								"exception",
								"   when others",
								"   then logger.log_error(const_pkg.c_when_others_message, v_scope);",
								"        raise;",
								"end f_delete;",
								"",
							],
				 "description": "(TMS) TAPI Delete Function in a Package Body with Logger Statements"
			  },
			  "Execute TAPI-Function Package Body": {
				  "scope": "plsql",
				  "prefix": ["function","func"],
				  "body": [  "",
								 "/*! ",
								 " * Function to Execute/Manage DML in the table",
								 " *",
								 " * @param pi_command",
								 " * @param pi_row ",
								 " *",
								 " * @author  Florian Yvan",
								 " * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
								 " * @return  ",
								 " */",
								 "function f_execute(",
								 "  pi_command in const_pkg.t_code",
								 " ,pi_row     in $tablename%rowtype",
								 " ) return call_result",
								 "is ",
								 "   v_scope     logger_logs.scope%type := gc_scope_prefix || 'f_execute';",
								 "   v_params    logger.tab_param;",
								 "   v_return    call_result;",
								 "begin   ",
								 "   logger.append_param(v_params,'pi_command',pi_command);",
								 "   logger.append_param(v_params,'pi_row.$pk',pi_row.$pk);",
								 "   logger.log('START',v_scope,null,v_params); ",
								 "\t\t",
								 "   case pi_command",
								 "     when const_pkg.c_command_insert then v_return := f_insert(pi_row);",
								 "     when const_pkg.c_command_update then v_return := f_update(pi_row);",
								 "     when const_pkg.c_command_delete then v_return := f_delete(pi_row);",
								 "     else v_return := handle_pkg.err_message(",
								 "         pretius_apex_util_pkg.f_lang('PRETIUS_TAPI_WRONG_COMMAND_ERROR')",
								 "        ,v_scope",
								 "        );",
								 "   end case;",
								 "\t\t",
								 "   logger.log('STOP', v_scope, null, v_params); ",
								 "   return(v_return); ",
								 "exception",
								 "   when others",
								 "   then logger.log_error(const_pkg.c_when_others_message, v_scope);",
								 "        raise;",
								 "end f_execute;",
								 "",
							 ],
				  "description": "(TMS) TAPI Execute Function in a Package Body with Logger Statements"
				},
				"ExistsPK TAPI-Function Package Body": {
					"scope": "plsql",
					"prefix": ["function","func"],
					"body": [  "",
								  "/*! ",
								  " * Function to Check existence of row",
								  " *",
								  " * @param pi_$pk ",
								  " *",
								  " * @author  Florian Yvan",
								  " * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
								  " * @return  ",
								  " */",
								  "function f_exists(",
								  "  pi_$pk  in $tablename.$pk%type",
								  " ) return boolean",
								  "is ",
								  "   v_scope     logger_logs.scope%type := gc_scope_prefix || 'f_exists';",
								  "   v_params    logger.tab_param;",
								  "   v_return    boolean;",
								  "   v_count     number := 0;",
								  "begin   ",
								  "   logger.append_param(v_params,'pi_$pk',pi_$pk);",
								  "   logger.log('START',v_scope,null,v_params); ",
								  "\t\t",
								  "   select count(1)",
								  "     into v_count",
								  "     from $tablename",
								  "    where $pk = pi_$pk;",
								  "\t\t",
								  "   logger.log('Exists row count: '||v_count, v_scope);",
								  "\t\t",
								  "   case v_count",
								  "     when 0",
								  "     then v_return := false;",
								  "     else v_return := true;",
								  "   end case;",
								  "\t\t",
								  "   logger.log('STOP', v_scope, null, v_params); ",
								  "   return(v_return); ",
								  "exception",
								  "   when others",
								  "   then logger.log_error(const_pkg.c_when_others_message, v_scope);",
								  "        raise;",
								  "end f_exists;",
								  "",
							  ],
					"description": "(TMS) TAPI Exists Function in a Package Body with Logger Statements"
				 },

				"ExistsUK 2 TAPI-Function Package Body": {
					"scope": "plsql",
					"prefix": ["function","func"],
					"body": [  "",
								  "/*! ",
								  " * Function to Check existence of row",
								  " *",
								  " * @param pi_$pk ",
								  " * @param pi_$uk2 ",
								  " *",
								  " * @author  Florian Yvan",
								  " * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
								  " * @return  ",
								  " */",
								  "function f_exists(",
								  "  pi_$pk     in $tablename.$pk%type",
								  " ,pi_$uk2    in $tablename.$uk2%type",
								  " ) return boolean",
								  "is ",
								  "   v_scope     logger_logs.scope%type := gc_scope_prefix || 'f_exists';",
								  "   v_params    logger.tab_param;",
								  "   v_return    boolean;",
								  "   v_count     number := 0;",
								  "begin   ",
								  "   logger.append_param(v_params,'pi_$pk',pi_$pk);",
								  "   logger.append_param(v_params,'pi_$uk2',pi_$uk2);",
								  "   logger.log('START',v_scope,null,v_params); ",
								  "\t\t",
								  "   select count(1)",
								  "     into v_count",
								  "     from $tablename",
								  "    where $pk  = pi_$pk",
								  "      and $uk2 = pi_$uk2;",
								  "\t\t",
								  "   logger.log('Exists row count: '||v_count, v_scope);",
								  "\t\t",
								  "   case v_count",
								  "     when 0",
								  "     then v_return := false;",
								  "     else v_return := true;",
								  "   end case;",
								  "\t\t",
								  "   logger.log('STOP', v_scope, null, v_params); ",
								  "   return(v_return); ",
								  "exception",
								  "   when others",
								  "   then logger.log_error(const_pkg.c_when_others_message, v_scope);",
								  "        raise;",
								  "end f_exists;",
								  "",
							  ],
					"description": "(TMS) TAPI Exists Function in a Package Body with Logger Statements"
				 },
				 "GetPK TAPI-Function Package Body": {
					 "scope": "plsql",
					 "prefix": ["function","func"],
					 "body": [  "",
									"/*! ",
									" * Function to download a row based on the PK",
									" *",
									" * @param pi_$pk ",
									" *",
									" * @author  Florian Yvan",
									" * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
									" * @return  ",
									" */",
									"function f_get(",
									"  pi_$pk  in $tablename.$pk%type",
									" ) return $tablename%rowtype",
									"is ",
									"   v_scope     logger_logs.scope%type := gc_scope_prefix || 'f_get';",
									"   v_params    logger.tab_param;",
									"   v_return    $tablename%rowtype;",
									"begin   ",
									"   logger.append_param(v_params,'pi_$pk',pi_$pk);",
									"   logger.log('START',v_scope,null,v_params); ",
									"\t\t",
									"   select *",
									"     into v_return",
									"     from $tablename",
									"    where $pk = pi_$pk;",
									"\t\t",
									"   logger.log('STOP', v_scope, null, v_params); ",
									"   return(v_return); ",
									"exception",
									"   when others",
									"   then logger.log_error(const_pkg.c_when_others_message, v_scope);",
									"        raise;",
									"end f_get;",
									"",
								],
					 "description": "(TMS) TAPI Get Function in a Package Body with Logger Statements"
				  },
				  "GetUK2 TAPI-Function Package Body": {
					  "scope": "plsql",
					  "prefix": ["function","func"],
					  "body": [  "",
									 "/*! ",
									 " * Function to download a row based on the PK",
									 " *",
									 " * @param pi_$pk ",
									 " * @param pi_$pk2 ",
									 " *",
									 " * @author  Florian Yvan",
									 " * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
									 " * @return  ",
									 " */",
									 "function f_get(",
									 "  pi_$pk  in $tablename.$pk%type",
									 " ,pi_$pk2 in $tablename.$pk2%type",
									 " ) return $tablename%rowtype",
									 "is ",
									 "   v_scope     logger_logs.scope%type := gc_scope_prefix || 'f_get';",
									 "   v_params    logger.tab_param;",
									 "   v_return    $tablename%rowtype;",
									 "begin   ",
									 "   logger.append_param(v_params,'pi_$pk',pi_$pk);",
									 "   logger.append_param(v_params,'pi_$pk2',pi_$pk2);",
									 "   logger.log('START',v_scope,null,v_params); ",
									 "\t\t",
									 "   select *",
									 "     into v_return",
									 "     from $tablename",
									 "    where $pk = pi_$pk",
									 "      and $pk2 = pi_$pk2;",
									 "\t\t",
									 "   logger.log('STOP', v_scope, null, v_params); ",
									 "   return(v_return); ",
									 "exception",
									 "   when others",
									 "   then logger.log_error(const_pkg.c_when_others_message, v_scope);",
									 "        raise;",
									 "end f_get;",
									 "",
								 ],
					  "description": "(TMS) TAPI Get Function in a Package Body with Logger Statements"
					},
		  "Function Package Body (ofs-satellites)": {
			  "scope": "plsql",
			  "prefix": ["function","func"],
			  "body": [  "",
				"/*! ",
				" * Function $DESCRIPTION",
				" *",
				" * @param $pi_param ",
				" *",
				" * @author  Florian Yvan",
				" * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
				" * @return  $return",
				" */",
				"function $function_name(",
				"  $pi_param   in $rowtype%type",
				" ) return $return_type",
				" is",
				"   l_context constant varchar2(60) := c_package_name|| '$function_name';",
				"   l_params  clob;",
				"   l_return  $return_type;",
				"begin   ",
				"   l_params := pkg_global_util.add_param(l_context,l_params,'$pi_param ='||$pi_param);",
				"   pkg_global_util.p_trace(l_context,pkg_global_util.c_trace_normal,'Start'); ",
				"\t\t",
				"\t\t",
				"\t\t",
				"   pkg_global_util.p_trace(l_context,pkg_global_util.c_trace_normal,'End'); ",
				" return(l_return);",
				"exception   ",
				"   when others   ",
				"   then pkg_global_util.p_trace(l_context,pkg_global_util.c_trace_overview, 'ERROR!! Exception When Others#');",
				"        pkg_global_util.p_log_errors(",
				"          in_layer         => pkg_global_util.c_layer_backend",
				"         ,in_object_type   => pkg_global_util.c_object_function",
				"         ,in_object_name   => l_context",
				"         ,in_errorstack    => dbms_utility.format_error_stack||dbms_utility.format_error_backtrace",
				"         ,in_pkval_1       => $pkVal1",
				"         ,in_programmermsg => '$ProgrammerMessage'",
				"         ,out_error_id     => v_exception_id",
				"        );",
				"        pkg_global_util.p_trace(l_context,pkg_global_util.c_trace_overview, 'Error successfully Logged!');",
				"end $function_name;",
				"",
			],
			  "description": "(OFS)Function in a Package Body"
			},
			"Function Package Body (CNSDB-satellites)": {
				"scope": "plsql",
				"prefix": ["function","func"],
				"body": [  "",
				 "/*! ",
				 " * Function $DESCRIPTION",
				 " *",
				 " * @param $pi_param ",
				 " *",
				 " * @author  Florian Yvan",
				 " * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
				 " * @return  $return",
				 " */",
				 "function $function_name(",
				 "  $pi_param   in $rowtype%type",
				 " ) return $return_type",
				 " is",
				 "   l_context constant varchar2(60) := c_package_name|| '$function_name';",
				 "   l_params  clob;",
				 "   l_return  $return_type;",
				 "begin   ",
				 "   l_params := pkg_global_util.add_param(l_context,l_params,'$pi_param ='||$pi_param);",
				 "   pkg_global_util.p_trace(l_context,pkg_global_util.gc_trace_normal,'Start'); ",
				 "\t\t",
				 "\t\t",
				 "\t\t",
				 "   pkg_global_util.p_trace(l_context,pkg_global_util.gc_trace_normal,'End'); ",
				 " return(l_return);",
				 "exception   ",
				 "   when others   ",
				 "   then pkg_global_util.p_trace(l_context,pkg_global_util.gc_trace_overview, 'ERROR!! Exception When Others#');",
				 "        pkg_global_util.p_log_errors(",
				 "          in_layer         => pkg_global_util.gc_layer_backend",
				 "         ,in_object_type   => pkg_global_util.gc_object_function",
				 "         ,in_object_name   => l_context",
				 "         ,in_errorstack    => dbms_utility.format_error_stack||dbms_utility.format_error_backtrace",
				 "         ,in_pkval_1       => $pkVal1",
				 "         ,in_programmermsg => '$ProgrammerMessage'",
				 "         ,out_error_id     => v_exception_id",
				 "        );",
				 "        pkg_global_util.p_trace(l_context,pkg_global_util.gc_trace_overview, 'Error successfully Logged!');",
				 "        return pkg_global_util.f_build_result(",
				 "           pi_is_success    => false",
				 "         , pi_context       => l_context",
				 "         , pi_error_message => dbms_utility.format_error_stack||dbms_utility.format_error_backtrace",
				 "        );",
				 "end $function_name;",
				 "",
			 ],
				"description": "(CNSDB)Function in a Package Body"
			 },
		  "Procedure Package Body": {
			  "scope": "plsql",
			  "prefix": ["proc","procedure"],
			  "body": [  "",
							 "/*! ",
							 " * Procedure $DESCRIPTION",
							 " *",
							 " * @param $pi_param ",
							 " *",
							 " * @author  Florian Yvan",
							 " * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
							 " */",
							 "procedure $procedure_name(",
							 "  $pi_param   in $rowtype%type",
							 " ) ",
							 " is",
							 "   v_scope    logger_logs.scope%type := gc_scope_prefix || '$procedure_name';",
							 "   v_params   logger.tab_param;",
							 "begin   ",
							 "   logger.append_param(v_params,'$pi_param',$pi_param);",
							 "   logger.log('START',v_scope,null,v_params); ",
							 "\t\t",
							 "\t\t",
							 "\t\t",
							 "   logger.log('STOP', v_scope, null, v_params); ",
							 "exception   ",
							 "   when others   ",
							 "   then logger.log_error(const_pkg.c_when_others_message, v_scope);",
							 "        raise;",
							 "end $procedure_name;",
							 "",
						 ],
			  "description": "(TMS)Procedure in a Package Body with Logger Statements"
			},

			"Procedure Package Ajax": {
				"scope": "plsql",
				"prefix": ["proc","procedure"],
				"body": [  "",
							  "/*! ",
							  " * Procedure $DESCRIPTION",
							  " *",
							  " * @author  Florian Yvan",
							  " * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
							  " */",
							  "procedure $procedure_name",
							  " is",
							  "   v_scope    logger_logs.scope%type := gc_scope_prefix || '$procedure_name';",
							  "   v_params   logger.tab_param;",
							  "   v_result   call_result;",
							  "begin   ",
							  "   logger.append_param(v_params,'$pi_param',apex_application.g_x01);",
							  "   logger.log('START',v_scope,null,v_params); ",
							  "\t\t",
							  "\t\t",
							  "   ajax_common_pkg.print(",
							  "      pi_call_result => v_result",
							  "     ,pi_context     => v_scope",
							  "   );",
							  "\t\t",
							  "   logger.log('STOP', v_scope, null, v_params); ",
							  "exception   ",
							  "   when others   ",
							  "   then logger.log_error(const_pkg.c_when_others_message, v_scope);",
							  "        tms_utils_pkg.p_ajax_errors(v_scope);",
							  "end $procedure_name;",
							  "",
						  ],
				"description": "(TMS)Procedure in a Package Body with Logger Statements"
			 },
			"Procedure Package Body[noLogger]": {
				"scope": "plsql",
				"prefix": ["proc","procedure"],
				"body": [  "",
							  "/*! ",
							  " * Procedure $DESCRIPTION",
							  " *",
							  " * @param $pi_param ",
							  " *",
							  " * @author  Florian Yvan",
							  " * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
							  " */",
							  "procedure $procedure_name(",
							  "  $pi_param   in $rowtype%type",
							  " ) ",
							  " is",
							  "   l_context constant varchar2(60) := c_package_name|| '$procedure_name';",
							  "begin   ",
							  "   pkg_intermon_util.sp_trace(l_context,pkg_intermon_util.c_trace_high,'param $pi_param ='||$pi_param );   ",
							  "   pkg_intermon_util.sp_trace(l_context,pkg_intermon_util.c_trace_normal,'Start'); ",
							  "\t\t",
							  "\t\t",
							  "\t\t",
							  "   pkg_intermon_util.sp_trace(l_context,pkg_intermon_util.c_trace_normal,'End'); ",
							  "exception   ",
							  "   when others   ",
							  "   then pkg_intermon_util.sp_perform_rollback(l_context);",
							  "        v_error := (dbms_utility.format_error_stack ||dbms_utility.format_error_backtrace);",
							  "        pkg_intermon_util.sp_trace(l_context,pkg_intermon_util.c_trace_overview, 'ERROR!! Exception When Others: ErrMsg#'||chr(10)||v_error);",
							  "        pkg_intermon_util.sp_log_errors(",
							  "          in_layer         => pkg_intermon_util.c_layer_backend",
							  "         ,in_object_type   => pkg_intermon_util.c_object_procedure",
							  "         ,in_object_name   => l_context",
							  "         ,in_errorstack    => v_error",
							  "         ,in_pkval_1       => $pkVal1",
							  "         ,in_programmermsg => '$ProgrammerMessage'",
							  "         ,out_error_id     => v_exception_id",
							  "        );",
							  "        pkg_intermon_util.sp_trace(l_context,pkg_intermon_util.c_trace_overview, 'Error successfully Logged!');",
							  "end $procedure_name;",
							  "",
						  ],
				"description": "(ICCA)Procedure in a Package Body without Logger Statements"
			 },
			 "Procedure Package Body(ofs-satellites)": {
				"scope": "plsql",
				"prefix": ["proc","procedure"],
				"body": [  "",
							  "/*! ",
							  " * Procedure $DESCRIPTION",
							  " *",
							  " * @param $pi_param ",
							  " *",
							  " * @author  Florian Yvan",
							  " * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
							  " */",
							  "procedure $procedure_name(",
							  "  $pi_param   in $rowtype%type",
							  " ) ",
							  " is",
							  "   l_context constant varchar2(60) := c_package_name|| '$procedure_name';",
							  "   l_params  clob;",
							  "begin   ",
							  "   l_params := pkg_global_util.add_param(l_context,l_params,'$pi_param ='||$pi_param);",
							  "   pkg_global_util.p_trace(l_context,pkg_global_util.c_trace_normal,'Start'); ",
							  "\t\t",
							  "\t\t",
							  "\t\t",
							  "   pkg_global_util.p_trace(l_context,pkg_global_util.c_trace_normal,'End'); ",
							  "exception   ",
							  "   when others   ",
							  "   then pkg_global_util.p_perform_rollback(l_context);",
							  "        pkg_global_util.p_trace(l_context,pkg_global_util.c_trace_overview, 'ERROR!! Exception When Others: ErrMsg#'||chr(10)||v_error);",
							  "        pkg_global_util.p_log_errors(",
							  "          in_layer         => pkg_global_util.c_layer_backend",
							  "         ,in_object_type   => pkg_global_util.c_object_procedure",
							  "         ,in_object_name   => l_context",
							  "         ,in_errorstack    => dbms_utility.format_error_stack ||dbms_utility.format_error_backtrace",
							  "         ,in_pkval_1       => $pkVal1",
							  "         ,in_programmermsg => '$ProgrammerMessage'",
							  "         ,out_error_id     => v_exception_id",
							  "        );",
							  "        pkg_global_util.p_trace(l_context,pkg_global_util.c_trace_overview, 'Error successfully Logged!');",
							  "end $procedure_name;",
							  "",
						  ],
				"description": "(OFS)Procedure in a Package Body"
			  },
			"View": {
				"scope": "plsql",
				"prefix": ["view","create","create or replace"],
				"body": [ "set define off;",
					        "",
							  "prompt ***",
							  "prompt *** Creating View $schema.$TM_FILENAME_BASE ",
							  "prompt ***",
					        "\t",
							  " create or replace view $schema.$TM_FILENAME_BASE",
							  " as",
							  "    select /*",
							  "            *",
							  "            *",
							  "            *",
							  "            * @author  Florian Yvan",
							  "            * @created $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR",
							  "            */",
							  "      from ",
							  "          ;",
							  "  show errors; ",
					        "",
							  " prompt ***",
							  " prompt ***Comment on the View and its columns",
							  " prompt ***",
							  "   comment on table $schema.$TM_FILENAME_BASE is '' ",
						  ],
				"description": "Creating/Modifying a view"
			 },
			 "Table": {
				 "scope": "plsql",
				 "prefix": ["table","create"],
				 "body": [ "set define off;",
								"",
								"prompt ***",
								"prompt *** Creating Table $schema.$TM_FILENAME_BASE",
								"prompt ***",
								"\t",
								" create table $schema.$TM_FILENAME_BASE",
								" ($seqno                number generated always as identity",
								"                       (start with 1 increment by 1)",
								" ,insert_on            date         not null",
								" ,insert_by            varchar2(50) not null",
								" ,last_updated_on      date",
								" ,last_updated_by      varchar2(50)",
								" ,",
								" );",
								"",
								"prompt ***",
								"prompt *** $TM_FILENAME_BASE Primary Key",
								"prompt ***",
								"   alter table $schema.$TM_FILENAME_BASE",
								"      add constraint $constrName_pk",
								"      primary key($seqno)",
								"      using index tablespace $tablespacename;",
								"",
								"prompt ***",
								"prompt ***  Table/Column comments",
								"prompt ***",
								"   comment on table $schema.$TM_FILENAME_BASE is '$tableDescripton';",
								"",
								"",
								"prompt ***",
								"prompt *** $TM_FILENAME_BASE creation complete",
								"prompt ***",
							],
				 "description": "Creating a Table"
			  },
			  "Foreign Key in Table": {
				  "scope": "plsql",
				  "prefix": ["constraint"],
				  "body": [ "constraint $constraint_name",
								 "  foreign key ($column_name)",
								 "  references $schema.$referenced_table($referenced_column) ",
							 ],
				  "description": "Foreign Key in the table definition itself"
				},
				"Check constraint in Table": {
					"scope": "plsql",
					"prefix": ["constraint"],
					"body": [ "constraint $constraint_name",
								  "  check($column_name)"
							  ],
					"description": "Check Constraint in the table definition itself"
				 },
				 "Unique Key - Alter Table": {
					 "scope": "plsql",
					 "prefix": ["alter"],
					 "body": [ "",
						        "prompt ***",
						        "prompt ***",
						        "prompt *** $TM_FILENAME_BASE Unique Key",
						        "  alter table $schema_name.$TM_FILENAME_BASE",
									"    add constraint $constraint_name",
									"    unique($column_name)",
									"    using index tablespace $tablespacename;"
								],
					 "description": "Unique Key Constraint in the alter table constraint"
				  },
				  "Handle OK Message": {
					  "scope": "plsql",
					  "prefix": ["handle","handle_pkg"],
					  "body": [ "handle_pkg.ok_message(",
									 "\t   pretius_apex_util_pkg.f_lang('PRETIUS_TAPI_SUCCESS_LOAD')",
									 "\t , null",
									 "\t , v_scope",
									 "\t);"
								 ],
					  "description": "Foreign Key in the table definition itself"
					},
					"Handle Error Message": {
						"scope": "plsql",
						"prefix": ["handle","handle_pkg"],
						"body": [ "handle_pkg.err_message(",
									  "\t pretius_apex_util_pkg.f_lang('PRETIUS_TAPI_WRONG_COMMAND_ERROR')",
									  "\t,v_scope",
									  "\t);"
								  ],
						"description": "Foreign Key in the table definition itself"
					 },
					 "(OFS)build_result": {
						 "scope": "plsql",
						 "prefix": ["f_build","f_build_result","pkg_global_util.f_build_result"],
						 "body": [ "pkg_global_util.f_build_result(",
										"\t pi_is_success    => $is_success",
										"\t,pi_context       => $l_context",
										"\t,pi_error_message => $error",
										"\t);"
									],
						 "description": "(OFS)Build the Result to be passed around"
					  },
					  "(OFS)T-Result": {
						  "scope": "plsql",
						  "prefix": ["t_result"],
						  "body": [ "pkg_global_util.t_result"
									 ],
						  "description": "(OFS)T-Result"
						},
					  "(OFS)Error Stack": {
						  "scope": "plsql",
						  "prefix": ["dbms_utili","dbms_utility.format","pkg_global_util.f_build_result"],
						  "body": [ "dbms_utility.format_error_stack||dbms_utility.format_error_backtrace "
									 ],
						  "description": "(OFS)Error Stack"
						},
						"(OFS) Webservice RESTFul": {
							"scope": "plsql",
							"prefix": ["f_make_rest_request","pkg_global_util.f_make_rest_request"],
							"body": [ "pkg_global_util.f_make_rest_request(",
										  "\t pi_app_module    => $pi_app_module",
										  "\t,pi_request_descr => $pi_request_descr",
										  "\t,pi_log_request   => $pi_log_request",
										  "\t,pi_url           => $pi_url",
										  "\t,pi_http_method   => $pi_http_method",
										  "\t,pi_body          => $pi_body",
										  "\t);"
									  ],
							"description": "(OFS)Webservice RESTful"
						 }
}
